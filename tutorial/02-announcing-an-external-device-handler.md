# Building an External Device Handler

To build an external device handler for netifd, certain criteria have to be met and some conventions followed.
Netifd needs some information about the device handler to generate the appropriate stub and device representations. The information has to be provided to netifd in a JSON description file.

## The JSON Description File

Netifd looks for JSON files in `/lib/netifd/ubusdev-config` to generate device handler stubs.
The files have to have a `.json` extension and must contain a properly-formatted JSON object **on a single line with proper EOF termination** as created when using
```bash
cat <<EOF > handler.json
> ...
> EOF
```
This is a bit tedious and will hopefully be made easier in the future.

A JSON description file contains the following fields:

| Name      | Type    | Required | Explanation |
| --------- | ------  | :------: | ----------- |
| name      | string  | yes | Name of the device type. It is what has to be put as the `type` option of the interface in `/etc/config/network`. (**Case sensitive**)|
| ubus_name | string  | yes      | Name of the external device handler's ubus object. The device handler generated by netifd uses this name to look up and subscribe to your external device handler |
| bridge    | boolean | no, *default: false* | Setting this to "1" or true signals that the device has bridge capabilities meaning it can host member devices |
| br-prefix | string  | yes *if bridge = true* | Used to make devices easily recognizable. This string is prepended to the name of every device of this type |
| config    | array   | yes      | The `config` field is a list containing name-integer pairs in separate lists. These describe the 'option' fields in `/etc/config/network`. See below for more explanation and an example. |
| info      | array   | no       | The `info` list uses the same format as the `config` list. It describes the data format of the reply to a `dump_info` ubus call to the external device handler. Netifd needs to be able to parse this reply in order to dump the information along with the one it can gather itself. If no `info` list is given, the `dump_info` call will be disabled. |
| stats     | array   | no       | This works exactly like `info` but for the `dump_stats` ubus method |


The arrays to describe arguments and their data types have a special format: They are arrays of other arrays with exactly two entries.
The sub-arrays' first entry is the name of the option. The second one encodes the data type.
For example, to enable netifd to parse the string option `private_key`, this list has to be put *into* the `"config"` list: 
```javascript
["private_key", 3]
```
The numbers describing the data type correspond to the values of `enum blobmsg_type` in [libubox](http://git.openwrt.org/?p=project/libubox.git;a=blob;f=blobmsg.h;h=84997a67ab5bc347dab0bd0a741bd0fd98ecddb5;hb=HEAD):
 *0. unspecified
 *1. Array
 *2. Table
 *3. String
 *4. 64-bit integer
 *5. 32-bit integer
 *6. 16-bit integer
 *7. 8-bit integer (doubles as boolean)

## Example

This fictional example description file demonstrates how to make netifd connect to an external device handler called "aclbr". The made up "ACL Bridge" devices provide stateless firewalling and per-port byte and packet counters.
*Note, that the actual file would have to written on a single line as explained above.*

```json
{
  "name" : "ACL Bridge",
  "ubus_name" : "aclbr",
  "bridge" : "1",
  "br-prefix" : "abr",
  "config" : [
    ["name", 3],
    ["ifname", 1],
    ["empty", 7],
    ["acl", 2]
  ],
  "info" : [
    ["ports", 1],
    ["acl", 2]
  ],
  "stats" : [
    ["bytes_per_port", 2],
    ["packets_per_port", 2]
  ]
}
```

Provided with this description file, netifd will create a device handler stub for devices where type is "ACL Bridge". It will try to subscribe to a ubus object called `aclbr` and attempt to call methods at that destination.
Since `bridge` is set to `1`, netifd will treat "ACL Bridge" devices as capable of hosting members. Any "ACL Bridge" device's name will be prepended with "abr" resulting in a device called "abr-lan", if an interface called `lan` is configured to be of type "ACL Bridge".
Netifd expects to find the following fields in the configuration:

 * An option called `name` with a string value
 * An option called `ifname` with a list value
 * An option called `empty` with a boolean (8-bit integer) value and
 * An option called `acl` with a table value

This could look something like this:

```bash
# /etc/config/network

interface 'lan'
  option 'type' 'ACL Bridge'
  option 'ifname' 'eth0 eth1'
  option 'empty' 'false'
  option 'acl' '1.2.3.0/24:deny 1.2.4.0/24:allow'
```

If the device is queried using `ubus call network.device status "{'name': 'abr-lan'}"`, netifd will look for the following fields in the reply:

 * a list of `ports` and
 * a table called `acl`.

Under statistics, the following fields will be added to the ones netifd gathers anyway:

 * a table of `packets_per_port` and
 * a table of `bytes_per_port`.
